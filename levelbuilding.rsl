inc "aslalg.mlb"
inc "aslalg.sml"
inc "levelbuilding-external.sml"

(*
  The interpretation is an interval (start frame to end frame) for a word
  with the distance for that word and the score of a predecessor. The
  total distance of the sentence is predecessor distance + interval distance
*)
interp:
    testFrames: int vector
    level : int
    word : int
    score : real
    interval : int * int
    prevs : int list * real

(* Reject any sequences that are illegal *)
fn grammarCheck(itemMap, grammar) {
    print "Checking grammar\n"
    [KillBadGrammar] if observing word, prevs badGrammar(itemMap, grammar, 3) {
        reject
    }
    print "Grammar checked\n"
}

fn makeLevel(itemMap, grammar) {
    print "Leveling up\n"
    [NextLevel] munge: levelUpMunge(itemMap)
    (* LevelUp just created a set of interps at new highest level, so 
       only look at those *)
    [InternalLevelCheck] if all observing level atMax {
        print "Scoring "
        print all observing level: len
        [ScoreLevel] update score observing interval, level, word: scoreLevel(itemMap)
        [KillHighScores] if observing score scoredOut {
            reject
        }
        print "Getting prevs\n"
        [GetPrevs] update all prevs observing score, interval, level, word: updatePrevs

        grammarCheck(itemMap, grammar)

        [TrimToBest] if all observing word, interval, prevs notBest {
            reject
        }
    }
}

fn finish(itemMap, grammar) {
    [GetAtEnd] if observing interval, testFrames atEnd {
        [AddEnd] update word, prevs, score: addEnd(itemMap)
    }
    else {
        reject
    }
    grammarCheck(itemMap, grammar)
}

fn levelbuildingLoop( itemMap, grammar ) {
    (*
    [LevelCheck] while all observing level belowMaxLevel( numLevels ) {
    *)
        print all observing level: prlevel
        print all observing level: len
        [OnlyHighestLevel] if all observing level atMax {
            makeLevel(itemMap, grammar)
            (* makeLevel() made a new, higher level. Drop the old one *)
            print "Dropping old incomplete\n"
            [DropOldLevels] if all observing level, interval, testFrames
                            oldIncompleteLevel {
                reject
            }
        }
    (*
    }
    *)
}

fn main ( testDir, levels ) {
    test = testDir
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val numLevels = valOf(Int.fromString(levels))
        val grammar = aslalgLoad t1 train test
        val itemMap = itemIndexMap()
        val scoreFile = (testDir ^ "/allMahalanobisScore.scores")
    (*ML*)

    [Init] munge: init
    [LoadVideo] update testFrames: getIds
    print "Trained and loaded\n"
    print all: loadScores( scoreFile )

    [LevelZero] update level, word, interval, score, prevs
                observing testFrames: levelZero(itemMap)
    print "Level zero intervals created\n"

    levelbuildingLoop( itemMap, grammar )
    levelbuildingLoop( itemMap, grammar )
    levelbuildingLoop( itemMap, grammar )

    print "Done leveling\n"

    finish( itemMap, grammar )

    print: i2s(itemMap)

    print "DONE DONE DONE\n"
}

