inc "aslalg.mlb"
inc "aslalg.sml"
inc "levelbuilding-external.sml"

(*
  The interpretation is an interval (start frame to end frame) for a word
  with the distance for that word and the score of a predecessor. The
  total distance of the sentence is predecessor distance + interval distance
*)
interp:
    testFrames: int vector
    level : int
    word : int
    score : real
    interval : int * int
    prevs : int list * real

fn grammarCheck(itemMap, grammar) {
    print "Checking grammar "
    print all observing level: len
    [KillBadGrammar] if observing word, prevs badGrammar(itemMap, grammar, 3) {
        print "Rejecting:\n"
        (* print: i2s(itemMap) *)
        reject
    }
    print "Grammar checked "
    print all observing level: len
}

fn makeLevel(itemMap, grammar) {
    print "Leveling up "
    print all observing level: len
    [NextLevel] munge: levelUpMunge(itemMap)
    print all observing level: prlevel
                    (*
                    [NextLevel] update all level
                                observing testFrames, word, interval: levelUp(itemMap)
                    *)
    (* LevelUp just created a set of interps at new highest level, so 
       only look at those *)
    print "Getting atMax "
    print all observing level: len
    [InternalLevelCheck] if all observing level atMax {
        print "Scoring "
        print all observing level: len
        [ScoreLevel] update score observing interval, level, word: scoreLevel(itemMap)
        [KillHighScores] if observing score scoredOut {
            print "Killing score-out\n"
            reject
        }
        print: i2s(itemMap)
    }
    print "Getting prevs "
    print all observing level: len
    [GetPrevs] update all prevs observing score, interval, level, word: updatePrevs
    grammarCheck(itemMap, grammar)
    [InternalLevelCheck] if all observing level atMax {
        [TrimToBest] if all observing word, interval, prevs
                     notBestForEnd {
            print "Not best "
            print all observing level: len
            reject
         }
    }
}

fn finish(itemMap, grammar) {
    [GetAtEnd] if observing interval, testFrames atEnd {
        [AddEnd] update word, prevs
                 observing score: addEnd(itemMap)
    }
    else {
        reject
    }
    grammarCheck(itemMap, grammar)
}

fn main ( testDir ) {
    test = testDir (* "/home/bholm/USF-ASL-Data-Set-v2/Sentence 12.5 why" *)
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val grammar = aslalgLoad t1 train test
        val itemMap = itemIndexMap()
    (*ML*)

    [Init] munge: init
    [LoadVideo] update testFrames: getIds
    print "Trained and loaded\n"
    print all observing level: len

    [LevelZero] update level, word, interval, score, prevs
                observing testFrames: levelZero(itemMap)
    print "Level zero intervals created\n"
    print all observing level: len

    [LevelCheck] while all observing level belowMaxLevel( 20 ) {
        print all observing level: prlevel
        print all observing level: len
        [OnlyHighestLevel] if all observing level atMax {
            print "Making level "
            print all observing level: len
            makeLevel(itemMap, grammar)
        }
        print "Dropping old incomplete "
        print all observing level: len
        [DropOldLevels] if all observing level, interval, testFrames
                        oldIncompleteLevel {
            reject
        }
    }

    print "Done leveling\n"

    finish( itemMap, grammar )

    print ifile
}

