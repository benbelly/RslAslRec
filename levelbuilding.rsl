inc "aslalg.mlb"
inc "aslalg.sml"
inc "levelbuilding-external.sml"

(*
  The interpretation is an interval (start frame to end frame) for a word
  with the distance for that word and the score of a predecessor. The
  total distance of the sentence is predecessor distance + interval distance
*)
interp:
    testFrames: int vector
    level : int
    word : int
    interval : int * int * real
    prevs : int list * real

fn makeLevel(itemMap) {
    [NextLevel] update level, word, interval
                observing testFrames: levelUp(itemMap)
    (* LevelUp just created a set of interps at new highest level, so 
       only look at those *)
    [InternalLevelCheck] if all observing level atMax {
        (* [DeleteDuplicates] fold *)
        [ScoreLevel] update interval observing level, word: scoreLevel(itemMap)
        [GetPrevs] update all prevs observing interval, level, word: updatePrevs
    }
}

fn main ( ) {
    test = "/home/bholm/USF-ASL-Data-Set-v2/Sentence 2.5 lipread cannot i"
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    (*ML*)
        val _ = aslalgLoad train test
        val itemMap = itemIndexMap()
    (*ML*)

    [Init] munge: init
    [LoadVideo] update testFrames: getIds
    print "Trained and loaded"
    print all: len

    [LevelOne] update level, word, interval, prevs
               observing testFrames: levelOne(itemMap)
    print "Level one intervals created"
    print all: len

    [ScoreLevelOne] update interval observing level, word: scoreLevel(itemMap)
    print "Level one scored"

    [LevelCheck] while all observing level belowMaxLevel( 20 ) {
        print all observing level: max
        [OnlyHighestLevel] if all observing level atMax {
            makeLevel(itemMap)
        }
    }

    print ifile
}

