inc "aslalg.mlb"
inc "aslalg.sml"
inc "levelbuilding-external.sml"
inc "lb-report.sml"

(*
  The interpretation is an interval (start frame to end frame) for a word
  with the distance for that word and the score of a predecessor. The
  total distance of the sentence is predecessor distance + interval distance
*)
interp:
    testFrames: int vector
    level : int
    word : int
    score : real
    interval : int * int
    prevs : (int * int * int) list * real

fn makeLevel(alpha, itemMap, grammar) {
    [NextLevel] munge: levelUpMunge(itemMap)
    (* LevelUp just created a set of interps at new highest level, so 
       only look at those *)
    [InternalLevelCheck] if all observing level atMax {
        [ScoreLevel] update score observing interval, level, word: scoreLevel(alpha, itemMap)
        [KillHighScores] if observing score scoredOut {
            reject
        }
    }

    [GetPrevs] update all prevs
               observing score, interval, level, word: updatePrevs( itemMap, grammar, 3 )

    [InternalLevelCheck] if all observing level atMax {
        [TrimToBest] if all observing word, interval, prevs notBest {
            reject
        }
    }
}

fn finish(itemMap, grammar) {
    [GetAtEnd] if observing interval, testFrames atEnd {
        [AddEnd] update word, prevs, score
                 observing interval: addEnd(itemMap)
    }
    else {
        reject
    }
    [KillBadGrammar] if observing word, prevs badGrammar(itemMap, grammar, 3) {
        reject
    }
}

fn levelbuildingLoop( alpha, numLevels, itemMap, grammar ) {
    [LevelCheck] while all observing level belowMaxLevel( numLevels ) {
        print all observing level: prlevel
        [OnlyHighestLevel] if all observing level atMax {
            makeLevel(alpha, itemMap, grammar)
            (* makeLevel() made a new, higher level. Drop the old one *)
            print "Dropping old incomplete\n"
            [DropOldLevels] if all observing level, interval, testFrames
                            oldIncompleteLevel {
                reject
            }
        }
    }
}

fn main ( alphaStr, levels, truthString, testDir ) {
    test = testDir
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val alpha = valOf(Real.fromString alphaStr)
        val numLevels = valOf(Int.fromString(levels))
        val grammar = aslalgLoad t1 train test
        val itemMap = itemIndexMap()
        val scoreFile = (testDir ^ "/allMahalanobisScore." ^ alphaStr ^ ".scores")
        val _ = loadScores( scoreFile )
    (*ML*)

    [Init] munge: init
    [LoadVideo] update testFrames: getIds
    print "Trained and loaded\n"

    [LevelZero] update level, word, interval, score, prevs
                observing testFrames: levelZero(itemMap)

    levelbuildingLoop( alpha, numLevels, itemMap, grammar )

    print "Done leveling\n"

    finish( itemMap, grammar )

    print: i2s(itemMap)

    [GetBest] if all observing score notBestScore {
        reject
    }

    [OnlyBest] accept
    print "The best interpretation:\n"
    print: i2s(itemMap)

    print "DONE DONE DONE\n"
}

hfn report ( alpha, levels, truthString, testDir ) {
    test = testDir
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val alpha = valOf(Real.fromString alphaStr)
        val numLevels = valOf(Int.fromString(levels))
        val grammar = aslalgLoad t1 train test
        val itemMap = itemIndexMap()
    (*ML*)
    hadd ["OnlyBest"]
    print: sPrintLevenshteinDistance(itemMap, truthString)
}
