inc "aslalg.mlb"
inc "aslalg.sml"
inc "levelbuilding-external.sml"
inc "lb-report.sml"

(*
  The interpretation is an interval (start frame to end frame) for a word
  with the distance for that word and the score of a predecessor. The
  total distance of the sentence is predecessor distance + interval distance
*)
interp:
    testFrames: int vector
    level : int
    word : int
    score : real
    interval : int * int
    prevs : (int * int * int) list * real

fn makeLevel(alpha, itemMap, grammar) {
    [NextLevel] munge: levelUpMunge(itemMap)
    print all observing level: prlevelAt( "NextLevel" )
    (* LevelUp just created a set of interps at new highest level, so 
       only look at those *)
    [InternalLevelCheck] if all observing level atMax {
        [ScoreLevel] update score observing interval, word: scoreLevel(alpha, itemMap)
        print all observing level: prlevelAt( "ScoreLevel" )
    }

    [GetPrevs] update all prevs
               observing score, interval, level, word: updatePrevs( itemMap, grammar)
    print all observing level: prlevelAt( "GetPrevs" )

    [LevelCheckForTrim] if all observing level atMax {
        [TrimToBest] if all observing word, score, interval, prevs notBest {
            print all observing level: prlevelAt( "ToTrim" )
            reject
        }
        print all observing level: prlevelAt( "UnTrimmed" )
    }
}

fn finish(itemMap, grammar) {
    [GetAtEnd] if observing interval, testFrames atEnd {
        [AddEnd] update word, prevs, score, interval: addEnd(itemMap)
    }
    else {
        reject
    }
    [KillBadGrammar] if observing word, prevs badGrammar(itemMap, grammar) {
        reject
    }
}

fn levelbuildingLoop( alpha, numLevels, itemMap, grammar ) {
    [WhileLevel] while all observing level belowMaxLevel( numLevels ) {
        print all observing level: prlevel
        [OnlyHighestLevel] if all observing level atMax {
            makeLevel(alpha, itemMap, grammar)
            (* makeLevel() made a new, higher level. Drop the old one *)
            [DropOldLevels] if all observing level, interval, testFrames
                            oldIncompleteLevel {
                print all observing level: prlevelAt( "DroppingOld" )
                reject
            }
        }
        [LevelEnd] accept
    }
}

fn main ( alphaStr, levels, testDir ) {
    test = testDir
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val alpha = valOf(Real.fromString alphaStr)
        val numLevels = valOf(Int.fromString(levels))
        val grammar = aslalgLoad t1 train test
        val itemMap = itemIndexMap()
        val scoreFile = (testDir ^ "/allMahalanobisScore." ^ ".scores")
        val str = loadScores( scoreFile )
        val _ = print str
    (*ML*)

    [Init] munge: init
    [LoadVideo] update testFrames: getIds
    print "Trained and loaded\n"

    [LevelZero] update level, word, interval, score, prevs
                observing testFrames: levelZero(itemMap)

    levelbuildingLoop( alpha, numLevels, itemMap, grammar )

    print "Done leveling\n"

    finish( itemMap, grammar )
    [Finished] accept

    print: i2s(itemMap)

    [GetBest] if all observing score notBestScore {
        reject
    }

    [OnlyBest] accept
    print "The best interpretation:\n"
    print: i2s(itemMap)

    print "DONE DONE DONE\n"
}

hfn report ( alphaStr, levels, testDir ) {
    test = testDir
    train = "/home/bholm/USF-ASL-Data-Set-v2"
    t1 = 300
    (*ML*)
        val alpha = valOf(Real.fromString alphaStr)
        val numLevels = valOf(Int.fromString(levels))
        val grammar = aslalgLoad t1 train test
        val ifilename = testDir ^ "/levelbuilding-" ^ alphaStr ^ "-ifile"
    (*ML*)
    (* print: sPrintLevenshteinDistance(itemMap, testDir) *)
    reject
    hadd ["LevelEnd"]
    hadd ["Finished"]
    write ifile to ifilename
}
