inc "ir-interp.sml"
inc "ir-report.sml"

interp:
    wordMap : (string * int) list
    alpha : real
    truth : (string * int * int) list
    range : int * int
    level : int
    word : string
    score : real
    interval : int * int
    prevs : (string * int * int) list * real
    editDistance: int
    editError: real

(*-------------------Display Helpers-----------------------------------*)
fn countAtAlpha( a ) {
    if observing alpha atAlpha(a) {
        print all: prForAlpha(a)
        print all: prCount
    }
}

fn threeCount() {
    countAtAlpha( 0.16 )
    countAtAlpha( 0.28 )
    countAtAlpha( 0.30 )
}

fn statsAtAlpha( a ) {
    if observing alpha atAlpha(a) {
        print all: prForAlpha(a)
        print "\n"
        print all observing editError: prMinError
        print all observing editError: prMaxError
        print all observing editError: prAvgError
    }
}

fn threeStats() {
    statsAtAlpha( 0.16 )
    statsAtAlpha( 0.28 )
    statsAtAlpha( 0.30 )
}

fn bests() {
    if all observing score bestScore {
        print "\tBest score\n"
        print: interpToString
        print "\n"
    }
    if all observing editError bestError {
        print "\tBest edit distance\n"
        print: interpToString
        print "\n\n"
    }
}

fn truthSoFarCount() {
    if isTruthSoFar {
        print "Truth so far "
        print all: prCount
    }
}
(*---------------------------------------------------------------------*)

(*-----------------Recursive grouping functions------------------------*)
(* 
fn eachGroupStats() {
    if all observing truth, alpha, level isNextGroup {
        print all observing truth, alpha, level prOneGroup
        print all prCount
        truthSoFarCount()
        bests()
    }
    else {
        eachGroupStats()
    }
}
*)

fn eachTruthStats() {
    if all observing truth isFirstTruth {
        print "\tHandling truth: "
        print all observing truth: prOneTruth
        print all: prCount
        threeStats()
    }
    else {
        eachTruthStats()
    }
}

fn eachTruthBestStats() {
    if all observing truth isFirstTruth {
        print "\tHandling truth: "
        print all observing truth: prOneTruth
        bests()
    }
    else {
        eachTruthBestStats()
    }
}

fn eachAlphaAndTruthBestStats() {
    if all observing alpha isFirstAlpha {
        eachTruthBestStats()
    }
    else {
        eachAlphaAndTruthBestStats()
    }
}

fn eachLevelAndTruthStats() {
    if all observing level isFirstLevel {
        print "Handling level: "
        print all observing level: prOneLevel
        print all: prCount
        truthSoFarCount()
        eachTruthStats()
    }
    else {
        eachLevelAndTruthStats()
    }
}

fn eachAlphaAndLevelAndTruthStats() {
    if all observing alpha isFirstAlpha {
        print "Handling alpha: "
        print all observing alpha: prOneAlpha
        eachLevelAndTruthStats()
    }
    else {
        eachAlphaAndLevelAndTruthStats()
    }
}

(*---------------------------------------------------------------------*)

fn main( interpfile ) {
    add interpfile
    update all wordMap observing truth, word, prevs: makewordmap
    update editDistance observing wordMap, truth, word, prevs, range, interval : levenshteinDistance
    [Error] update editError observing wordMap, truth, word, prevs, range, interval: levenshteinError

    if observing word atEnd {
        if isTruth {
            print "\n\nTruth:\n"
            threeCount()
            threeStats()
            eachAlphaAndTruthBestStats()
        }
        else {
            print "\n\n\nFailed:\n"
            threeCount()
            threeStats()
            eachAlphaAndTruthBestStats()
        }
    }

    print "---------------Level and Truth-------------------\n"
    eachAlphaAndLevelAndTruthStats()

    print "---------------Truth and Best--------------------\n"
    eachAlphaAndTruthBestStats()
}
