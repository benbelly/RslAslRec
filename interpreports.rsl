(**
    Copyright 2011 Ben Holm

    This file is part of RslAslRec.

    RslAslRec is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    RslAslRec is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with RslAslRec.  If not, see <http://www.gnu.org/licenses/>.
**)

inc "ir-interp.sml"
inc "ir-report.sml"

interp:
    wordMap : (string * int) list
    alpha : real
    truth : (string * int * int) list
    range : int * int
    level : int
    word : string
    score : real
    interval : int * int
    prevs : (string * int * int) list * real
    editDistance: int
    editError: real

(*-------------------Display Helpers-----------------------------------*)
fn countAtAlpha( a ) {
    if observing alpha atAlpha(a) {
        print all: prForAlpha(a)
        print all: prCount
    }
}

fn threeCount() {
    countAtAlpha( 0.16 )
    countAtAlpha( 0.28 )
    countAtAlpha( 0.30 )
}

fn statsAtAlpha( a ) {
    if observing alpha atAlpha(a) {
        print all: prForAlpha(a)
        print "\n"
        print all observing editError: prMinError
        print all observing editError: prMaxError
        print all observing editError: prAvgError
    }
}

fn threeStats() {
    statsAtAlpha( 0.16 )
    statsAtAlpha( 0.28 )
    statsAtAlpha( 0.30 )
}

fn bests() {
    if all observing score bestScore {
        print "\tBest score\n"
        print: interpToString
        print "\n"
    }
    if all observing editError bestError {
        print "\tBest edit distance\n"
        print: interpToString
        print "\n\n"
    }
}

fn truthSoFarCount() {
    if isTruthSoFar {
        print "Truth so far "
        print all: prCount
    }
}
(*---------------------------------------------------------------------*)

(*-----------------Recursive grouping functions------------------------*)
fn eachGroupStats( outfile ) {
    if all observing truth, alpha, level isNextGroup {
        (*
        print all observing truth, alpha, level: prOneGroup
        print all: prCount
        truthSoFarCount()
        bests()
        *)
        write ++ all to outfile: prGroupReport
    }
    else {
        eachGroupStats( outfile )
    }
}

(*---------------------------------------------------------------------*)

fn writeReportLine( outfile ) {
    write "Alpha\t Truth String\t Level\t Max Error\t Min Error\t Avg Error\t NumTruth\t NumInterps\t pctTruth\t Average Truth Error\t Average non-Truth Error\t fullMatch\n" to outfile
}

fn main( interpfile ) {
    (* ML *)
        oneSix = "cvsl_out/report-0.16-log"
        twoEight = "cvsl_out/report-0.28-log"
        threeOh = "cvsl_out/report-0.30-log"
    (* ML *)

    add interpfile
    update all wordMap observing truth, word, prevs: makewordmap
    update editDistance observing wordMap, truth, word, prevs, range, interval : levenshteinDistance
    [Error] update editError observing wordMap, truth, word, prevs, range, interval: levenshteinError

    (*
    if observing word atEnd {
        if isTruth {
            print "\n\nTruth:\n"
            threeCount()
            threeStats()
            eachGroupStats()
        }
        else {
            print "\n\n\nFailed:\n"
            threeCount()
            threeStats()
            eachGroupStats()
        }
    }
    *)

    if observing alpha atAlpha( 0.16 ) {
        writeReportLine( oneSix )
        eachGroupStats( oneSix )
    }
    if observing alpha atAlpha( 0.28 ) {
        writeReportLine( twoEight )
        eachGroupStats( twoEight )
    }
    if observing alpha atAlpha( 0.30 ) {
        writeReportLine( threeOh )
        eachGroupStats( threeOh )
    }

}
